# C
## 思考
図のような範囲を移動できるとき、あるコマからあるコマまでの最小移動回数を求める問題。
一目見てめんどそう…
とりあえず、サンプルを見てみる。

サンプル1を見ると、この時点で別解があることに気付く。
毎回よい操作があり、その操作をシミュレーションしていくとかはなさそうと予想する。

サンプル2は実は結構よい意味を持っているけど、最初見たときは気付かなかった。

サンプル3は遠い点でも斜め移動を駆使して3手でたどり着いてるパターン。
斜めに近い点だから移動回数少なくできるよなあって思った。
（これ書いているときに気付いたけど、斜めに全然近くない）

サンプル4はコーナーケース用。

後出しだけど、サンプルをしっかり観察していれば、
ここから下の考察はほとんど必要なかったように思える。
**教訓 図形問題系は、視覚的な考察が意味を持つ場合があるので、サンプルをしっかり図示したほうがよい**

サンプルを見ても、特にこれといった解法が重い浮かばない…
とりあえず、サンプルが手数の少ない手ばかりなので、
いじわるをして手数をできるだけ消費する手を考えてみる。

この移動範囲だと斜め移動は無限にできるので、
斜めに近い点よりも真上とか真横とかの方がきつそうに見える。
x座標かy座標のどちらか大きい方をそろえてから、
残った方の座標を地道に移動していくのかなと考えながら、以下の図を描いた。

あれ、y = x に垂直な方向の斜めも使えそうやん…？
実はこれはまさしくサンプル2の例である。
いくつかの点から y = x に対して垂線を下ろしてみて、交点が整数でない点が出てくるが、
これがゴールの近くまで行けて追加でもう1手必要なパターンなのかと気付く。
サンプル2と3を見比べて偶奇っぽいなあと思う。

ということで、任意の点まで3手以内でいけそう。
3手でいける手の集合が一番大きそうなので、0手, 1手, 2手でいける集合を列挙する。

- 0手
  - 同じマス

- 1手
  - 与えられている条件通り

- 2手
  - 5 * 5 のマス目内
  - 正方形からひとつ出っ張った部分
  - 斜め2手でいけるマス。（r, c）の偶奇が一致
  - 1回斜め移動したあとに、十分近い点。rとcの距離が3以下。

提出したコードが以下の通り。これでACでした。

```rust
use proconio::{input, marker::Chars, source};
type VS = Vec<String>;
 
pub fn main() {
    input!{
        r1: i32,
        c1: i32,
        r2: i32,
        c2: i32
    };
    let target = (r2-r1, c2-c1);
    if target.0 == 0 && target.1 == 0 {
        println!("{}", "0");
        return;
    }
    if target.0 == target.1 || target.0 == -target.1 {
        println!("{}", "1");
        return;
    }
    if target.0.abs() + target.1.abs() <= 3 {
        println!("{}", "1");
        return;
    }
    if target.0.abs() <= 5 && target.1.abs() <= 5 {
        println!("{}", "2");
        return;
    }
    if target.0 == 0 && target.1.abs() == 6 {
        println!("{}", "2");
        return;
    }
    if target.0.abs() == 6 && target.1 == 0 {
        println!("{}", "2");
        return;
    }
    if (target.0.abs()-target.1.abs()).abs() <= 3 {
        println!("{}", "2");
        return;
    }
    if target.0.abs() % 2 == target.1.abs() % 2 {
        println!("{}", "2");
        return;
    }
    println!("{}", "3");
}
```