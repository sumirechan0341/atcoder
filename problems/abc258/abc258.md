# C
## 思考

# D
## 思考
N個のステージがあり、(a<sub>i</sub>, b<sub>i</sub>)はステージiのムービー時間とプレイ時間を表している。
整数Xが与えられるので、X個ステージをクリアするときの最小時間を答える問題。
ただしステージiをクリアしないとステージi+1は選択できない。

今選択できるプレイ時間最小のステージをずっと選び続けるのは、最適な戦略ではない。
多少損しても、先のステージにもっと短いクリア時間のステージがあるかもしれないからである。
したがって基本的には全部のパターンを探索する必要がある。

ステージiまででクリア回数を達成すると仮定する。
ステージをどこまで進めるかを決めてしまえば、ステージのクリア順番は可換なので、
最初i回でステージiまで進めて、その後ステージiまででプレイ時間の最も短いステージを(x-i)回クリアし続ければよい。
この計算は、ステージiまででかかる時間の合計、ステージiまでの最小プレイ時間を累積和で持っておけば可能である。

```rust
use proconio::{input, marker::Chars};
pub fn main() {
    input! {
        n: usize,
        x: i64,
        abn: [(i64, i64); n]
    };
    let mut smin = vec![std::i64::MAX; n + 1];
    let mut sn = vec![0; n + 1];
    for i in 0..n {
        smin[i + 1] = smin[i].min(abn[i].1);
        sn[i + 1] = sn[i] + abn[i].0 + abn[i].1;
    }
    let mut ans = std::i64::MAX;

    for i in 0..n {
        ans = ans.min(sn[i + 1] + (x - i as i64 - 1) * smin[i + 1]);
    }
    println!("{}", ans);
}

```