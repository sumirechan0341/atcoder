# C
# 思考
数Nを-2進数表現で表す問題。
Nを正の数に固定し、Nの2進数表現と比べてみる。

偶数番目のbitは2進数表現と同じ数を表すことができるが、
奇数番目のbitはマイナスがつくので1を立てたときに違う数の表現になってしまう。
たとえば1000は2進数で8、-2進数で-8だがどうすれば-2進数で8にすることができるだろうか。

答えは、ひとつ上の桁から値を借りる方法である。
8は16-8で表現可能なので、11000となる。

これを踏まえた上でサンプルの9の例を見てみよう。
1001は下の桁から見ていって、
最初の1は(0-originで)偶数番目なので、
そのまま1を書き写す。
0もそのまま書き写し、最後の1は奇数番目なのでひとつ上の桁から借りて11にする。
したがって11001となる。
今回見た例は0が多く繰り上げの計算がなかったが実際には繰り上げの計算が必要になる。

もう一度おさらいしよう。
方針としては数の2進数表現をそのまま真似ていく。
1を立てる必要がある場合、もしそのbitが奇数番目だったらそのひとつ先のbitも立てる。
実装としては、1を立てるときだけ考え、現在地のbitが0か1かで次のように場合分けしている。
- 現在地のbitが0 && 現在地が偶数番目 => 現在地にそのまま1を立てる
- 現在地のbitが0 && 現在地が奇数番目 => 現在地と1つ上の桁の1を立てる
- 現在地のbitが1 && 現在地が偶数番目 => 現在地を0にし、1つ上の桁ともうひとつ上の桁に1を立てる（繰り上げが起こったが次の桁に1を立てるだけではだめ。）
- 現在地のbitが1 && 現在地が奇数番目 => 現在地を0にする（今奇数番目のbitで、この数はマイナスになっている。自分と同じ数が足されたということは、そのまま0にするだけでよい）

十分な長さのベクターを用意しておき、逆順になっているのでreverseして、最初に1が出てくるまでの区間を切り取れば答えになる。
```rust
use proconio::{input, marker::Chars};

pub fn main() {
    input! {
        n: i64
    };
    let mut d = vec![0; 100];
    if n != 0 {
        let mut nn = n.abs();
        for i in 0.. {
            if nn & 1 == 1 {
                carry(&mut d, i, 1, n > 0)
            }
            nn = nn >> 1;
            if nn == 0 {
                break;
            }
        }
    } else {
        println!("{}", 0);
        return
    }
    d.reverse();
    println!("{}", d.split_at(d.iter().position(|&x| x == 1).unwrap()).1.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(""));

}

fn carry(d: &mut Vec<i32>, cur: usize, bit: i32, sign: bool) {
    if bit == 0 {
        return;
    }
    if d[cur] == 0 {
        d[cur] = 1;
        let res = if sign { 1 } else { 0 };
        if cur % 2 == res {
            d[cur+1] = 1;
        }
    } else {
        d[cur] = 0;
        let res = if sign { 0 } else { 1 };
        if cur % 2 == res {
            d[cur+1] = 1;
            d[cur+2] = 1;
        } 
    }
}
```