# C
## 思考
1..Nの順列が与えられる。区間長Kを取り、その区間の値すべてをその区間の最小値に置き換えることを繰り返したときに、
すべての値が1になるときの最小手数を求める問題。
1を経由する前に違う数字にする必要はなさそうである。
1を貪欲に広げていく実験してみると次の性質が分かる。
- 1回の更新で変更される区間の長さはK-1
- 1の左側と右側を別々に更新する必要がある

この考えをもとに実装をする。
数列を「1」で分割して、分割後の数列2つに対して\(\lceil \frac{分割した数列の長さ}{(k-2)} \rceil\)
で必要回数を求める。
最後に足し合わせれば終わりである。
めでたしめでたし…とはならない。
1の左側と右側を独立して考えたが、実際にはそうはいかない。
例えば、以下の入力を考える。
4 4
2 1 3 4
分割する方法だと2になってしまう。
どうやら1付近に関しては、始点をずらして回数を減らすことができそうだ。
2*K分ずらしながら試してもいいのだが、計算で処理してしまおう。
もう一度上の例を考える。
1の右側の更新を行ったとき、変更できる区間長は3にもかかわらず、実際に変更した区間は2である。つまり長さ1の余力がある。左側に関しては長さ2の余力がある。併せて長さ3の余力があるが、ちょうどこれは1回分に相当する。この分を調整すれば消せるだろうという考えで、余力がK-1以上だった場合-1すればよい。
```rust
use proconio::{input, marker::Chars};
type VS = Vec<String>;

pub fn main() {
    input!{
        n: usize,
        k: usize,
        an: [i32; n]
    };
    let mut lr = an.split(|&x| x == 1);
    let leftlen = lr.next().unwrap().len();
    let rightlen = lr.next().unwrap().len();
    let left = (leftlen + k-2)/(k-1);
    let right = (rightlen + k-2)/(k-1);
    let left_remain = left*(k-1) - leftlen;
    let right_remain = right*(k-1) - rightlen;
    println!("{}", if left_remain + right_remain >= k-1 { left + right - 1 } else { left + right });
}
```