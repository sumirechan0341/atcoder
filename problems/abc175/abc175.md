# C
## 思考
基本的に0に向かって移動し続ければよいが、
0を飛び越える場合をしっかり考える必要がありそうだ。
とりあえず貪欲に0に近づいても、0を飛び越えない場合を先に処理しておく。
```rust
if k*d <= x.abs() {
  println!("{}", x.abs() - k*d);
  return;
}
```
0を飛び越える場合どのように移動するのが最適だろうか。
この問題では、ちょうどk回のジャンプをする必要があるが、
最初に「進む」「戻る」をペアで行えば、ジャンプ回数は2m回減らすことができる。
そして、この問題を考える上で必要以上のジャンプ回数を考える必要はない。
どうせ、行ったり来たりをして最終的には同じ地点まで戻ってくるからである。
ジャンプを必要最小限まで減らして、とりあえず+方向から0を超えないぎりぎりまでのジャンプを行う。
残ったジャンプ回数が奇数回の場合は、0をまたぐようにジャンプし、
偶数回ならばその場にとどまるのが最適である。
```rust
use proconio::{input, marker::Chars};
type VS = Vec<String>;

pub fn main() {
    input!{
        x: i128,
        k: i128,
        d: i128
    };
    if k*d <= x.abs() {
        println!("{}", x.abs() - k*d);
        return;
    }
    let remain = k - (x.abs()/d);
    if remain % 2 == 0 {
        println!("{}", x.abs() - (x.abs()/d) * d);
        return;
    } else {
        println!("{}", (x.abs() - (x.abs()/d + 1) * d).abs());
        return;
    }
}
```