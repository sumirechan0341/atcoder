# C
## 思考
M個の数直線上の点が与えられ、N個のコマを任意の数直線上に配置し、M個全部訪れるときの移動距離の総和を最小化する問題。
サンプルを見たときに貪欲解もパッと思いつかない。
少し考えると、コマを置く場所はX<sub>i</sub>上のどこかで一方向にしか動かないのが最適っぽいことがわかる。
行ったり来たりするのは無駄だからである。

ひとまずサンプル1を図示してみよう。
TODO: ここに図を入れる
右側と左側でなんとなくかたまりができているので、コマを左右に配置するのがよいのだろう。
でもコマがもっとあった場合は？
10がもうちょっと真ん中に寄っていて微妙なときは？

コマが1つのときを考えてみる。
左から順に移動していると、途中で移動距離が長い箇所が出てくる。
なるほど。視覚的に見えていたかたまりは隣り合った要素との差の大小で表現できそうだ。
コマが複数あれば、この大きい区間の移動は省略できそうである。
隣り合った要素との差をとった配列を、大きい順に並べてそこからN-1個取り除いた後の総和が答えになる。
```rust
use proconio::{input, marker::Chars};

pub fn main() {
    input! {
        n: usize,
        m: usize,
        mut xm: [i64; m]
    };
    xm.sort();
    let mut diff = vec![0; m-1];
    for i in 0..m-1 {
        diff[i] = xm[i+1] - xm[i];
    }
    diff.sort();
    diff.reverse();
    if n >= m {
        println!("{}", 0);
        return;
    }
    println!("{}", diff[(n-1)..].iter().sum::<i64>());
}
```