# C
## 思考
N個の数列があり、区間を決めて数を一斉に1大きくすることができる。
この操作を繰り返して、数列を模倣するのに最短何ステップ必要か求める問題。
できるだけ広い区間に対して1を足す操作を行いたいが、
何回か足していると目標に達してしまう要素が出てくる。
広義単調増加な領域に対して、必要な手数はその区間の最大値であるので、[^1]
広義単調増加な部分に切り出して計算を行おうとしたが、
切り出した区間はそれぞれ独立で扱うことができない。(サンプル3がわかりやすい)

最初の戦略に戻り、シミュレーションしてどのような処理が必要か見てみる。
できるだけ広い区間に+1を施すが、目標に達している部分で区間が何分かにされる。
その後はそれぞれの区間を別に考えてよい。なぜならば、ここまで各区間は貪欲に+1の処理が施されていてかつ、この後の処理は必ずわけて行う必要があるからである。
分割した区間に対して、同様の操作を行えば答えが出そうである。
長さ1の区間になれば、残った数字が必要操作量となる。

元の区間があって、長さが短くなった区間に対して同様の操作を行っているので、再帰を使った。
分割が起こるまでにかかった手数と、それぞれの区間に対して必要手数を足せばよい。
ただし、再帰に与える引数として、元の配列と同じ数値を渡すのではなく、分割が起こるまでにかかった手数を差し引いておかなければならない。分割が起こる前にその分を大きくしているからである。
```rust
use proconio::{input, marker::Chars};

pub fn main() {
    input! {
        n: usize,
        hn: [i32; n]
    };
    println!("{}", dfs(hn));
}

fn dfs(target: Vec<i32>) -> i32 {
    if target.is_empty() {
        return 0;
    } 
    if target.len() == 1 {
        return target[0];
    } else {
        for i in 0.. {
            let connected = target.split(|x| x == &i);
            if connected.clone().count() != 1 {
                return i + connected.fold(0, |acc, new_target| acc + dfs(new_target.iter().map(|x| x-i).collect::<Vec<_>>()));
            }
        }
        // unreachable
        return -500;
    }
}
```

[^1]: たとえば、[1, 4, 6]のような数列のとき、左端からどんどん操作をやめていけばよい。