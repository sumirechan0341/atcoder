# C
## 思考

# D
## 思考
長さNの数列A<sub>N</sub>が与えられる。
任意の数列の要素に対して、好きな回数以下の操作を行う。
- a<sub>i</sub> が2の倍数のとき、a<sub>i</sub> を a<sub>i</sub>/2 で置き換える
- a<sub>i</sub> が3の倍数のとき、a<sub>i</sub> を a<sub>i</sub>/3 で置き換える
Aのすべての要素が等しくなるような最小の操作回数を求める問題。

どんなときに等しくできないのか考えてみる。
サンプル2で与えられているように、
A = { 1, 6, 7 } のとき無理である。
これは、7がこれ以上変化できない数で、他の数と同じにできないからである。

ということで最初に思いつく方針は、すべての要素に対して、2と3で割れるだけ割ってみる戦法である。
この操作は十分間に合うし、実際これで不可能かどうかの判定はできている。

さて、次は最小回数を求められるように修正していこう。
どんなときに最小回数でない答えを出すのか考える。
たとえば、
A = { 6, 6, 6 } のときにこれ以上割るのは無駄である。
もう少し非自明な例を探してみる。
A = { 6, 3 } や A = { 7, 21 } も1まで割り切る必要はない。
前者は1まで割り切れるが、最小回数にならない例、後者はそもそも1にできないパターンである。
なんとなく約数関係が関与してそうに見えてくる。
A = { 2, 3, 6 } なども試してみて、たぶん全体の最大公約数をとって、その数になるまで2か3で割っていけば、最小回数も保証できそうに見える。
簡単に証明する。
- 操作回数の最小性
Aの最大公約数以上で数字をそろえることができれば、操作の最小回数性が担保できなくなるが、実際にはそのようなことはあり得ない。そろっているその数は、今割り算だけを実行して得られているので、元の数の約数になっている。
そろっているN個の数は、すべて元の数a<sub>i</sub>の約数なのに、最大公約数よりも大きいということは、最大公約数の最大性に反するので矛盾。

- GCDでそろえられるとき、GCD未満の値でもそろえられる
全体に対して2で割るか3で割るかすればよい。

- GCD未満の数でそろえられるとき、GCDでもそろえられる
今そろっている数は公約数になっている。どの要素も2か3を割る操作しかしていないからである。
全体に対する操作を、最大公約数になるまで1つずつ戻していけば、GCDでもそろえられることが分かる。

実装では、まず数列全体のGCDを求めておいて、GCDの値になるまで3で試し割りと2で試し割りを行った。
ただし、割り算をするときにGCD未満の結果になるときには、計算を止めた。
そのまま 計算結果 < gcd みたいな条件式を書くとバグる。
計算後の値がGCDを約数にもつかどうかで判定するとよく、それは計算後の値をGCDとgcdをとってGcdに等しければGCDを約数として持っていると判定できる。

```rust
use proconio::{input, marker::Chars};
use num::{integer, Integer};
pub fn main() {
    input! {
        n: usize,
        mut an: [i32; n]
    };
    let mut gcd = an[0];
    for i in 0..n {
        gcd = gcd.gcd(&an[i]);
    }
    let mut ans = 0;
    for i in 0..n {
        while an[i]%3 == 0 && an[i] != gcd {
            if (an[i]/3).gcd(&gcd) != gcd {
                break;
            }
            an[i]/=3;
            ans += 1;
        }
        while an[i]%2 == 0 && an[i] != gcd {
            an[i]/=2;
            ans += 1;
        }
        if an[i] != gcd {
            println!("{}", -1);
            return;
        }
    }
    println!("{}", ans);
}
```