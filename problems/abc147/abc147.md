# C
## 思考
N人の人がいて、それぞれの発言が矛盾しない最大の人数を求める問題。
Nが小さいので正直者のべき集合を全探索すればよい。
個人的には、集合を固定したあとに、それらの人の発言が矛盾しているかどうかの判定の方が苦労した。

正直者の集合 H = { h<sub>1</sub>, h<sub>2</sub>, ... h<sub>k</sub> }の発言が矛盾しないことを判定するために次の条件で判定することにした。
- \(H \in h_i\)が不親切と言った人はHに含まれていない
- \(H \in h_i\)が正直者と言った人はHに含まれる

前者の条件に関して、もしh<sub>i</sub>が不親切と言った人がHに含まれているならば、h<sub>i</sub>が正直者のとき、不親切と言われた人が正直者集合Hに含まれていることに矛盾するし、
h<sub>i</sub>が不親切ならば、そもそもHにh<sub>i</sub>が含まれていることが矛盾している。

一方で後者の条件は、矛盾しないことの必要条件ではない。たとえば、最大の正直者集合が{ A, B, C }だったとして、{ A, B }も正直者集合としては妥当であるが、AやBがCを正直者と言っていると、この条件では除外されてしまう。
2番目の条件があっても問題ない理由と、必要な条件について分けて説明する。
- 条件を付加しても問題ない理由
べき集合を全探索しているため、このプロセスで正直者集合と判断されなかった正直者集合があっても、その集合を含むより大きな正直者集合でカバーできる。
上の例で言うと{ A, B }では正直者集合に扱われなかったが、{ A, B, C }は正直者集合として扱われる。そして、今回のケースで求めたいのは最大の正直者集合なので、この方法で解の妥当性は損なわない。
- 条件の付加が必要な理由
正直者集合に含まれない人を正直というと矛盾が発生する場合が存在する。正直者集合の外の要素は、正直者か不親切な人なのかわからないので、もし不親切な人だった場合に矛盾が発生する。
サンプル2がよい例で、証言が単体もしくは小さい集合のときには妥当に見えるが、よくよく調べてみると実は矛盾しているというパターンがある。これらを除外するために、証言関係をすべて含む正直者集合で考える必要があり、そうでない集合のときは失敗とみなすようにしている。
```
 use proconio::{input, marker::Chars};
 
pub fn main() {
    input! {
        n: usize
    };
    let mut graph = vec![vec![0; n]; n];
    for i in 0..n {
        input! {
            a: usize,
            xya: [(usize, i32); a]
        };
        for (x, y) in xya {
            if y == 1 {
                graph[i][x-1] = 1;
            } else {
                graph[i][x-1] = -1;
            }
        }
        graph[i][i] = 1;
    }
    let mut max = 0;
    for i in 0..2_i32.pow(n as u32) {
        let mut ii = i;
        let mut indices = vec![];
        for j in 0..n {
            if ii & 1 == 1 {
                indices.push(j);
            }
            ii = ii >> 1;
        }
        // 全パターン試すので正直者の数が厳密に一致しなければ、失敗扱いでよい
        // 正直者グラフが閉じていて、中に不親切な人がいなければ無矛盾
        let mut ok = true;
        for j in &indices {
            for k in 0..n {
                if graph[*j][k] == 1 && !indices.contains(&k) {
                    ok = false;
                    break;
                }
                if graph[*j][k] == -1 && indices.contains(&k) {
                    ok = false;
                    break;
                }
            }
            if !ok {
                break;
            }
        }
        if ok && max < i.count_ones() {
            max = i.count_ones();
        }
    }
    println!("{}", max);
}
```