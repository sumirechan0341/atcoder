# C
## 思考

# D
## 思考
T個の問題が与えられるので、すべてに解答する問題。
問題は次の通りである。
3つ組(N, D, K)が与えられる。
次のルールに従ってN個のマス目にチェックを入れていくので、K番目にチェックがついた場所を答える。
- 最初はマス0にチェックを入れる
- 直前でチェックしたマス目から+D進んだマス目にチェックを入れる。
  ただし右端までいったときは左端に戻ってくる。
  また、進んだマスがチェック済みだった場合、チェックしていないマスが現れるまで、右に1マスずれる。

挙動が簡単なパターンから観察しよう。
NがDで割り切れるパターンは単純そうである。
0からD個飛ばしでチェックしていくと、N/D+1回目に0にちょうど戻ってくる。
このとき、+1してマス目1に移るが、この後の操作でまったく同様の推移をしてマス目1に戻ってきてマス目2に移る。  
つまり、マス目が埋まる順番は次のようになっている。
- 1 .. N/D回 0 -> D -> 2D -> ...
- N/D+1 .. 2*N/D  1 -> 1+D -> 1+2D ...
...

Kの数字が何番目のグループに入るかは、グループの長さ(つまり N/D)で何回割れるかで決まり、
そのグループの中でも何番目かはmod (N/D)を使えば求まるので、高速に答えを出すことができた。

さて、今度は数字を一般化してみよう。
とりあえず何回操作すれば、元の位置に戻ってくるのかが問題である。
いくつかの数字で試してみれば、lcm(N, D)/D 回で初めて元の位置に戻ってくることに気づける。
あとは同じ上で考えた同じ理屈で計算が可能である。

```rust
use proconio::{input, marker::Chars};
use num::Integer;
pub fn main() {
    input! {
        t: usize,
        testt: [(i64, i64, i64); t]
    };
    for (n, d, k) in testt {
        let order = n.lcm(&d)/d;
        println!("{}", (((k-1)/order)+d*((k-1)%order))%n);
    }
}
```