# C

## 思考

7 だけで構成される巨大な数が k の倍数になるかどうか判定する問題。
以下では 7 が n 桁続く数を「7<sub>n</sub>」と記すことにする。

解析的に解けるかどうか計算してみたが、厳しい。
長さに関して約数関係になっているもの(7<sub>2</sub>, 7<sub>4</sub>, 7<sub>6</sub> とか 7<sub>3</sub>, 7<sub>6</sub>, 7<sub>9</sub>)は、
その数自体も約数関係になっていることなどは分かるが、現れる素因数に関しては規則性がない。
ずっと考えていても仕方がないので、このような同じ数字が連続した数の性質について調べてみる。
1 だけで構成される数を特に Repunit 数というらしいが、
Repunit 数に関しての性質を見てみると、p が 2, 3, 5 以外の素数なら 1 が p-1 個現れる数は p の倍数になるらしい。
なるほど。サンプル 3 の例はこの性質のことを指しているらしい。
一方で、k が素数といえども、必ずしも k-1 が答えとなるわけではない。
サンプル 1 がその例で、101 は素数であるが、100 ではなく 4 が答えになっている。
k が合成数のときは、k = p \* q として、上の長さと約数の考察から 7<sub>(p-1)(q-1)</sub>で少なくとも k を倍数として持つ。
この時点で答えは必ず k-1 までで抑えられることがわかったので、
7<sub>n</sub> (n = 1 ~ k-1)が k の倍数かどうかを効率的に判定する方法を考える。

7<sub>n</sub> が k で割り切れるかどうかをそのまま考えると巨大な数をどうやって表すかという問題に直面する。
巨大な数と mod の相性がいいので、7<sub>n</sub> ≡ 0 (mod k)を解くイメージにして、
巨大な 7<sub>n</sub> を小さい 7<sub>n-1</sub>, 7<sub>n-2</sub>, ... で表現する方法を考える。
今回の問題では
7<sub>n</sub> - 7<sub>n-1</sub> = (7<sub>n-1</sub> - 7<sub>n-2</sub>) \* 10
という等式を利用して、計算を行った。
要は、7 ≡ x1, 70 ≡ (10 \* x1) ≡ x2, 700 ≡ (10 \* x2) ≡ x3, ... (mod k)を計算しただけである。

```rust
use proconio::{input, marker::Chars};

pub fn main() {
    input! {
        n: i32
    };
    if n==1 || n == 7 {
        println!("{}", 1);
        return;
    }
    let mut mod_total = 7;
    let mut mod_prev = 7;
    for i in 1..=n {
        let mod_now = (mod_prev * 10) % n;
        mod_prev = mod_now;
        mod_total += mod_now;
        mod_total %= n;
        if mod_total == 0 {
            println!("{}", i+1);
            return;
        }
    }
    println!("{}", -1);
    return;
}
```

n = 7 スタートにしたので、n より小さい値に注意。
実際に n = 1 のコーナーケースの処理を忘れて 1WA した。

# D
## 思考

長さN、文字「R」「W」からなる文字列が与えられ、
文字列を操作して「R」の左隣に「W」が来ないようにする。
できる操作は以下の2つである。

- 文字を1文字変える
- 文字2つを選んで場所を換える

操作回数の最小回数を求める問題。

文字を1文字変える操作よりも、場所を換える操作の方が操作回数を減らしやすいことが分かる。
2つの文字を入れ替えて、違反状態の文字を2箇所修正できる可能性があるからだ。
そのあとの方針が出てこない。
文字列がそこまで長くないので、入れ換え操作を貪欲に行うことをやってみる。

感覚として、左側にある「W」と右側にある 「R」は邪魔なので、これらを標的に入れ換えを行う。
文字列の左からのカーソルと右からのカーソルを2つ用意して、
現在のカーソルが左:「W」かつ右:「R」のとき、入れ換えを行う。
このとき操作回数を1増やし、それぞれのカーソルを次に進める。
左側のカーソルが「R」のときは、左側をどんどん進めてよいが、
「W」に遭遇したときは、右の「R」と交換できるまで足止めしておく。
右側も同様である。
左右のカーソルが出会えば終了で、そのときの操作回数が答えになる。
```rust
use proconio::{input, marker::Chars};
type VS = Vec<String>;

pub fn main() {
    input!{
        n: usize,
        cn: Chars
    };
    let mut r = n-1;
    let mut l = 0;
    let mut count = 0;
    while r > l {
        if cn[l] == 'W' && cn[r] == 'R' {
            count += 1;
            l += 1;
            r -= 1;
            continue;
        }
        if cn[r] == 'W' {
            r -= 1;
        }
        if cn[l] == 'R' {
            l += 1;
        }
        
    }
    println!("{}", count);
}
```