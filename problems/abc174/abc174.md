# C

## 思考

7 だけで構成される巨大な数が k の倍数になるかどうか判定する問題。
以下では 7 が n 桁続く数を「7<sub>n</sub>」と記すことにする。

解析的に解けるかどうか計算してみたが、厳しい。
長さに関して約数関係になっているもの(7<sub>2</sub>, 7<sub>4</sub>, 7<sub>6</sub> とか 7<sub>3</sub>, 7<sub>6</sub>, 7<sub>9</sub>)は、
その数自体も約数関係になっていることなどは分かるが、現れる素因数に関しては規則性がない。
ずっと考えていても仕方がないので、このような同じ数字が連続した数の性質について調べてみる。
1 だけで構成される数を特に Repunit 数というらしいが、
Repunit 数に関しての性質を見てみると、p が 2, 3, 5 以外の素数なら 1 が p-1 個現れる数は p の倍数になるらしい。
なるほど。サンプル 3 の例はこの性質のことを指しているらしい。
一方で、k が素数といえども、必ずしも k-1 が答えとなるわけではない。
サンプル 1 がその例で、101 は素数であるが、100 ではなく 4 が答えになっている。
k が合成数のときは、k = p \* q として、上の長さと約数の考察から 7<sub>(p-1)(q-1)</sub>で少なくとも k を倍数として持つ。
この時点で答えは必ず k-1 までで抑えられることがわかったので、
7<sub>n</sub> (n = 1 ~ k-1)が k の倍数かどうかを効率的に判定する方法を考える。

7<sub>n</sub> が k で割り切れるかどうかをそのまま考えると巨大な数をどうやって表すかという問題に直面する。
巨大な数と mod の相性がいいので、7<sub>n</sub> ≡ 0 (mod k)を解くイメージにして、
巨大な 7<sub>n</sub> を小さい 7<sub>n-1</sub>, 7<sub>n-2</sub>, ... で表現する方法を考える。
今回の問題では
7<sub>n</sub> - 7<sub>n-1</sub> = (7<sub>n-1</sub> - 7<sub>n-2</sub>) \* 10
という等式を利用して、計算を行った。
要は、7 ≡ x1, 70 ≡ (10 \* x1) ≡ x2, 700 ≡ (10 \* x2) ≡ x3, ... (mod k)を計算しただけである。

```rust
use proconio::{input, marker::Chars};

pub fn main() {
    input! {
        n: i32
    };
    if n==1 || n == 7 {
        println!("{}", 1);
        return;
    }
    let mut mod_total = 7;
    let mut mod_prev = 7;
    for i in 1..=n {
        let mod_now = (mod_prev * 10) % n;
        mod_prev = mod_now;
        mod_total += mod_now;
        mod_total %= n;
        if mod_total == 0 {
            println!("{}", i+1);
            return;
        }
    }
    println!("{}", -1);
    return;
}
```

n = 7 スタートにしたので、n より小さい値に注意。
実際に n = 1 のコーナーケースの処理を忘れて 1WA した。
