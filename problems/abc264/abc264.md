# C
## 思考

# D
## 思考
"atcoder"の文字列の順列が与えられる。
"atcoder"の文字列に復元するために隣り合う2つの文字をswapしたときに、最小回数を求める問題。

ぱっと思いつくのがバブルソートのアルゴリズムである。
バブルソートでは、現在の基点のインデックスiを持ち、
i-1番目までがソートされていて、i番目を正しい要素にすることを考える。
ソートされていない部分全体から、i番目に収まるべき要素を見つけてswapして移動していく。
この設定の場合、swapは後ろから行っていかないと、i番目に所望の要素を配置できないので気を付ける。
こうして、iの値を増やしていけば、全体として完全にソートした列が得られる。

今回はソートするのではなく、i番目として所望される要素が"atcoder"のi番目と直接わかるので、
やはり同様のアルゴリズムで実行可能である。
これでなぜ操作の最小性が担保されるのかは正直不明である。
```rust
use proconio::{input, marker::Chars};

pub fn main() {
    input! {
        mut s: Chars
    };
    let goal = ['a', 't', 'c', 'o', 'd', 'e', 'r'];
    let mut ans = 0;
    for i in 0..s.len() {
        for j in (i+1..s.len()).rev() {
            if s[j] == goal[i] {
                s.swap(j, j-1);
                ans += 1;
            }
        }
        
    }
    println!("{}", ans);
}
```